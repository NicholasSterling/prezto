#
# Executes commands at the start of an interactive session.
#

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# Customize to your needs...

bindkey -v

autoload zed

typeset -U path

### Ask a y/n question and succeed if y.
### e.g.   ask Delete $file && rm $file
###        ask -n Delete $file && rm $file  # defaults to n

ask() {
  local default
  local response
  [ "$1" = -y ] && default=y && shift
  [ "$1" = -n ] && default=n && shift
  echo ""
  while :; do
    echo -n "$@"'? '
    [ "$default" ] && echo -n "($default) "
    read -q response
    echo ""
    [ "$response" = $'\n' ] && response="$default"
    [ "$response" = y ] && return 0
    [ "$response" = n ] && return 1
    echo "Please enter y or n"
  done
}

alias a=alias
a \?='whence -vafs'
a \?m='noglob whence -vafsm'
a .z='. ~/.zprofile; . ~/.zshenv; . ~/.zshrc'
a v.z='v ~/.{zprofile,zshenv,zshrc}'
a dos2unix=fromdos
a fn='zed -f'
compctl -F fn

a git_sasi=' git clone git@github.com:Coraid/sasi.git '

a rmb='rm *~'
a rmrb='rm **/*~'

a h='history -iD'
a -g ,o='$(eval `fc -ln -1`)'  # output of last cmd (which gets re-executed)

a cx='chmod +x'

setenv() { export $1="$2" }     # for compatibility with simple csh scripts

say+do() { echo "$@"; "$@" }            # say it, then do it
warn()   { echo "$@" 1>&2 }             # say to stderr

a lines='print -lr'

# Grab selections to make a doc.
got=$HOME/got
grab() {
  local x
  echo "Output in \$got:  l = add horizontal line,  q = quit,  g = add X selection, whatever = add whatever"
  while :; do
    read x
    case "$x" in
      l) >&1 >&3 echo '================================================================================';;
      g) >&1 >&3 xsel;;
      q) break;;
      *) >&3 echo "$x";;
    esac
  done 3>$got
}

diskhogs() { du -ak | sed -n '/^[0-9]\{3\}/p' | sort -rn | $PAGER }
 cpuhogs() { ps -eo pcpu,pid,user,comm        | sort -rn | $PAGER }

a num='nl -ba'
a wsdiff='sdiff -w179'

# Show just the specified (by number) line.
line() {
  local num
  num=$1 shift
  sed -ne "${num}p" "$@"
}

psg() { ps -ef | egrep  "$@|UID" | grep -v grep }

a ie='vared -M viins 2>/dev/null'  # inline edit; gives weird error

##### Directories

# cd to a directory, creating it if it doesn't exist.
md () { mkdir -p "$1"            }
md.() { mkdir -p "$1" && cd "$1" }

# nd names a directory; cnd cd's to a named directory.
 nd() { export $1="$PWD"; : ~$1 }
cnd() { cd "$1" }
compctl -n cnd

# ls stuff
a lf='ls -CFbh'
a ll='ls -CFbhla'

# TREE stuff
a td='tree -d'         # just the dirs
a tf='tree -FC'        # all file types
a tm='noglob tf -P'    # ..     matching this pattern
a tn='noglob tf -I'    # .. not matching this pattern

# Edit a var or the current directory.  Edit path as lines.
v() {
  if [ $# = 1 ]; then
    if [ $1 = path ]; then
      local lpath
      lpath=$( path )
      ie lpath
      path=( "${=lpath}" )
    else
      ie $1
    fi
  else  # default is PWD
    local dir
    dir="$PWD"
    ie dir
    cd "$dir"
  fi
}
compctl -v v

# List previous directories and let me pick one.
pd() {
  dirs -v
  echo -n ' # '
  local num
  read -k num
  echo ''
  [ "$num" = $'\n' ] && pushd +1 && return
  [ "$num" -gt 0   ] && pushd +$num
}

# Warp to a similar directory -- one path component replaced.
wd() { cd "$1" "$2" }
wd_completions1() { reply=(`echo $PWD | sed 's:/: :g'`); }
wd_completions2() {
	local cmd arg1 rest
	read -c cmd arg1 rest
#	echo arg1 $arg1 >/dev/console
	prefix="${PWD%%${arg1}*}"
	reply=(`ls -d "$prefix"*(-/) | sed -e 's:/$::' -e 's:.*/::'`)
}
compctl -x 'p[1]' -K wd_completions1 - 'p[2]' -K wd_completions2 -- wd

# . with no args does cd -
. () { [ $# -eq 0 ] && cd - || builtin . "$@" }
a      ..='cd .. && lf'
a     ...='cd ../.. && lf'
a    ....='cd ../../.. && lf'
a   .....='cd ../../../.. && lf'
a  ......='cd ../../../../.. && lf'
a .......='cd ../../../../../.. && lf'

# Path display/manipulation.  See also 'v path'
path() { lines $path }
+path() { PATH="$1:$PATH"; path }
path+() { PATH="$PATH:$1"; path }

##### Time

 dateInSecs() { date +%s }
 secsToDate() {      date -d @$1                            '+%Y-%m-%d %H:%M:%S' }
msecsToDate() { d=$( date -d @$( echo $1 | sed 's/...$//' ) '+%Y-%m-%d %H:%M:%S' ); echo $d.$( echo $1 | sed 's/.*\(...\)/\1/' ) }

##### Archives

function grepJars {
  what=`echo "$1" | sed s:\\\\.:/:g`
  for jar in ${2:-**/*.jar}; do
    output=`jar tf $jar | grep "$what"` && echo "  *** $jar ***\\n$output"
  done
}

##### Curl

# curl with cookie jar; put/post @file or string
export CU_URL=http://localhost:8080
export CU_JAR=~/.cookie_jar
cu-to  () { export CU_URL=http://${1-localhost}:8080; export CU_JAR=${2-~/.cookie_jar}; }
cu-url () { CU_URL="$1"; }
cu-jar () { CU_JAR="$1"; }
cu-put () { local x="$1"; shift; cu_ "$@" -X PUT -d "$x"; }
cu-post() { local x="$1"; shift; cu_ "$@"        -d "$x"; }
cu-del () {                      cu_ "$@" -X DELETE     ; }
cu-new () {
    rm -f   "$CU_JAR"
    curl -c "$CU_JAR" "$CU_URL/j_acegi_security_check?j_username=${1-admin}&j_password=${2:-changeme}"
}
cu-yaml_   () {
    local url="$CU_URL/$1"
    shift
    curl -b "$CU_JAR" \
         -H 'Content-Type: application/yaml' \
         -H       'Accept: application/yaml' \
         "$url" "$@"
}
cu-csv_   () {
    local url="$CU_URL/$1"
    shift
    curl -b "$CU_JAR" \
         -H       'Accept: application/csv' \
         "$url" "$@"
}
cu-text_   () {
    local url="$CU_URL/$1"
    shift
    curl -b "$CU_JAR" \
         -H       'Accept: text/plain' \
         "$url" "$@"
}
cu_() {
    local url="$CU_URL/$1"
    shift
    curl -b "$CU_JAR" "$url" "$@"
}
cu-nicon () { cu_ "Debug/NICMetricsOn"  -d ""; }
cu-nicoff() { cu_ "Debug/NICMetricsOff" -d ""; }
a cu-yaml=" noglob cu-yaml_ "
a cu-csv="  noglob cu-csv_  "
a cu-text=" noglob cu-text_ "
cu-help() {
<<EOF cat

CU_URL = $CU_URL
CU_JAR = $CU_JAR
cu-to lmyun2 /tmp/cookiejar
cu-new
cu-yaml Path/vm1?depth=3
cu-put 'status: RUNNING' Path/vm1
cu-post "{ name: iie, type: Container }" Path/
cu-del Path/vm1
cu-csv Metrics/Vm?begin=2011-03-01

You can use @file instead of literal data.

EOF
}
 task() { curl           -sD -         $sc_url/Task/$1 ; }
 getP() { curl           -sD -         $sc_url/Path$1  ; }
postP() { curl           -sD - -d "$2" $sc_url/Path$1  ; }
 putP() { curl -X PUT    -sD - -d "$2" $sc_url/Path$1  ; }
 delP() { curl -X DELETE -sD -         $sc_url/Path$1  ; }
 dump() { curl           -sD -         $sc_url/Dump    ; }

# sk kills SASI jobs (core.Boot).
sk() { kill $( psg java | fgrep core.Boot | awk '{ print $2 }' ) }

a nobuf='stdbuf -oL'  # actually, it's still buffered by line

# Shows a subset of the available events.
a eventgrep='nobuf events | grep'

##### A calculator using (( )).
#####   , 3.5 * 8
#####   / 7
#####   -
##### For trig, rand, more:  zmodload zsh/mathfunc

typeset -F z=0.0
a calc='noglob calc_'
calc_() {
    if [ $# = 2 ]; then
      [ "$2" = \+ ] && set -- "$1" \+ "$1"   #  3 +  =>    3 + 3
      [ "$2" = \- ] && set -- 0.0  \- "$1"   #  3 -  =>  0.0 - 3
      [ "$2" = \* ] && set -- "$1" \* "$1"   #  3 *  =>    3 * 3
      [ "$2" = \/ ] && set -- 1.0  \/ "$1"   #  3 /  =>  1.0 / 3
    fi
    (( z = $* ))
    echo $z | sed -e 's/0*$//' -e 's/\.$//'
}
a      ,='calc'
a      z='calc z'
a      0='calc 0.0'
a      1='calc 1.0'
a      2='calc 2.0'
a -- '+'='calc z +'
a -- '-'='calc z -'
a -- '*'='calc z *'
a -- '/'='calc z /'
int() {    # z = $1 (or $z) converted to an integer
  local int
  declare -i 10 int
  int=${1-z}
  calc $int
}
round() {    # z = $1 (or $z) rounded to nearest integer
  local int
  declare -i 10 int
  (( int = ${1-z} + .5 ))
  calc $int
}
16() {    # print $1 (or $z) in hex
  local int
  declare -i 16 int
  int=${1-$z}
  echo $int
}
  

# Commit staged changes with the JIRA magic to close an issue.
function gjc {   # e.g. gjc 219 Blah blah blah
  local nnn=$1
  shift
  say+do git commit -m "USM-$nnn #resolve $*"
}

# Commit staged and unstaged changes with the JIRA magic to close an issue.
function gjca {   # e.g. gjca 219 Blah blah blah
  local nnn=$1
  shift
  say+do git commit -am "USM-$nnn #resolve $*"
}

##########

bindkey '^[[Z' reverse-menu-complete
bindkey ''   undo
bindkey ''   describe-key-briefly
bindkey '^O'   overwrite-mode

keys() { cat <<EOF

         ^\  describes next key
         ^/  undo
         ^J pushes input
         ^u  kill line
         ^k  kill line to right
         ^o  toggle overwrite mode
      Alt-h  help (man page) for cmd
      Alt-d  delete word
      Alt-b  back word
      Alt-f  fore word
      Alt-t  xpos word
      Alt-d  kill word
 Ctrl-Alt-h  kill word backwards
 Ctrl-Alt-g  send break
  Shift-TAB  reverse menu complete

See also:
  bindkey
  man zshzle

EOF
}

